lane_id: "lane_15_code_generation"
wave: "wave0"
target_base: "dino_qwen4b"
source_type: "local"

# template_expand lanes do not require source files
sources: []

# how many rows to build (can be overridden by --limit)
count_target: 2353
# REQUIRED PCT fields: keep these in the human-facing lane configs
base_row:
  adult_gate: false
  profanity_allowed: false
  needs_search: false
  needs_history_search: false
  emote6: neutral
  continuity_choice: "suppress_continuity"
  flow_state: "none"
  history_scope: "thread_only"
  representation_choice: "plain_text"
  safety_tag: "safe"

  system_prompt_id: "dino.system.v1"
# forward-compat placeholders
language_mix: {}
synthetic_policy: {}
required_tools: []
validators:
  - name: "mode_richness"
mode_richness:
  think_min_chars: 420
  think_min_steps: 0
transform_pipeline: []

generation_mode: "template_expand"
system_prompt_path: prompts/system/dino_system_prompt.txt


output_dir: out_runs/colleague_test

teacher_runtime:
  sample_percent: 5
  enabled: false
  provider: ollama
  ollama_host: "http://127.0.0.1:11434"
  model: "dino-pro-7b"
  policy: structure_only
  on_missing_evidence: abstain
  system_prompt_path: prompts/teacher/lane_15_teacher_system_prompt.txt




  timeout_s: 150
  keepalive: "5m"
# similarity/dedupe controls (tune per-lane)
similarity:
  max_token_overlap_ratio: 0.3
  ignore_stopwords: true
  ignore_tokens: ["dino", "ai", "assistant", "im", "i'm"]
  ngram: 3

template_expand:
  seed: 0
  count_target: 2353
  slot_banks:
    language: ["ja"]
    mode: ["think"]
    tone: ["professional", "serious", "professional", "serious", "friendly", "family", "best_friend"]
    emote6: ["neutral"]
    continuity_choice: ["suppress_continuity"]
    representation_choice: ["plain_text"]

    intent_family: ["content_generation"]
    intent_subtype: ["code_generation"]

    needs_search: [false]
    needs_history_search: [false]
    history_scope: ["thread_only"]
    safety_tag: ["safe"]

    code_task:
      - "implement a small utility"
      - "fix a bug in a function"
      - "refactor a short snippet"
      - "add input validation"
      - "write a parser"
      - "transform a data list"
      - "build a small helper"
      - "write a formatter"
      - "add error handling"
      - "clean and normalize text"

    language_hint:
      - "Python"

    input_shape:
      - "a list of strings"
      - "a list of numbers"
      - "a plain text block"
      - "a CSV-like string"
      - "a list of key-value lines"
      - "a short list of pairs"

    output_shape:
      - "a cleaned list"
      - "a summary string"
      - "a filtered result"
      - "a boolean answer"
      - "a normalized mapping"
      - "a structured dictionary"
      - "a validated value"

    constraint_line:
      - "Keep it readable and short."
      - "Avoid external libraries."
      - "Handle empty input safely."
      - "Prefer clear names over clever tricks."
      - "Include a minimal example."
      - "Add a short docstring or comment."
      - "Keep the function pure if possible."
      - "Return early on invalid input."

    bug_snippet:
      - |
        def pick_even(nums):
            out = []
            for n in nums:
                if n % 2 == 1:
                    out.append(n)
            return out
      - |
        def safe_div(a, b):
            return a / b
        # crashes when b is zero
      - |
        def parse_kv(text):
            pairs = [p.split('=') for p in text.split(',')]
            return dict(pairs)
        # breaks on spaces
      - |
        def sum_all(nums):
            total = 0
            for i in range(len(nums) + 1):
                total += nums[i]
            return total
      - |
        def title_words(s):
            parts = s.split(' ')
            return ' '.join(p[0].upper() + p[1:] for p in parts)
        # fails on empty parts
      - |
        def unique_items(items):
            seen = []
            out = []
            for item in items:
                if item in seen:
                    out.append(item)
                else:
                    seen.append(item)
            return out

    refactor_goal:
      - "make it easier to test"
      - "separate parsing from formatting"
      - "reduce repeated logic"
      - "handle edge cases explicitly"
      - "make failure modes clear"
      - "improve readability"
      - "simplify branching"
      - "add small safeguards"

    feature_goal:
      - "deduplicate items"
      - "group items by a key"
      - "validate simple input"
      - "parse a small config"
      - "format output consistently"
      - "filter by a rule"
      - "compute a small summary"
      - "normalize text"
      - "trim and clean fields"
      - "map values to labels"

    code_language_tag: ["python"]

    code_snippet:
      - |
        def normalize_items(items):
            if not items:
                return []
            cleaned = []
            seen = set()
            for raw in items:
                item = str(raw).strip().lower()
                if not item or item in seen:
                    continue
                seen.add(item)
                cleaned.append(item)
            return cleaned
      - |
        def safe_divide(a, b):
            if b in (0, 0.0):
                return None
            return a / b
      - |
        def parse_kv(text):
            if not text:
                return dict()
            out = dict()
            for part in text.split(','):
                if '=' not in part:
                    continue
                k, v = part.split('=', 1)
                out[k.strip()] = v.strip()
            return out
      - |
        def unique_list(items):
            if not items:
                return []
            seen = set()
            out = []
            for raw in items:
                item = str(raw).strip().lower()
                if not item or item in seen:
                    continue
                seen.add(item)
                out.append(item)
            return out
      - |
        def sum_safe(nums):
            if not isinstance(nums, list):
                return 0
            total = 0
            for n in nums:
                total += int(n) if str(n).strip() else 0
            return total
      - |
        def group_pairs(pairs):
            out = dict()
            for k, v in pairs or []:
                out.setdefault(k, []).append(v)
            return out
      - |
        def clamp(n, lo, hi):
            if n < lo:
                return lo
            if n > hi:
                return hi
            return n
      - |
        def to_lines(text):
            if not text:
                return []
            lines = str(text).splitlines()
            return [line.strip() for line in lines if line.strip()]
      - |
        def choose_first(items):
            if not items:
                return None
            return items[0]
      - |
        def has_value(text):
            if text is None:
                return False
            return bool(str(text).strip())

    bullet_line_a:
      - "Task: {code_task} in {language_hint}."
      - "Goal: {feature_goal} with safe defaults."
      - "Focus: {refactor_goal}."
      - "Inputs: {input_shape}."
      - "Outputs: {output_shape}."
      - "Constraint: {constraint_line}"

    bullet_line_b:
      - "If the input is missing, return a safe empty value."
      - "Keep the interface small and predictable."
      - "Prefer explicit checks over implicit assumptions."
      - "Use names that match the intent."
      - "Avoid surprising side effects."
      - "Make edge cases obvious in code."
      - "Bad: assume valid input. Good: guard early and return safe defaults."
      - "Bad: mix parsing and formatting. Good: separate them into small steps."

    bottom_line:
      - "The snippet stays small, readable, and safe on empty input."
      - "This keeps the behavior predictable while covering edge cases."
      - "The code prioritizes clarity and basic safeguards."
      - "This is a minimal, testable starting point."

    next_step:
      - "Tell me the exact inputs and expected outputs, and I will tailor it."
      - "Share a concrete example and I will refine the function."
      - "Paste your real snippet and I will adapt this structure."
      - "Confirm the edge cases you care about most."

    request_text:
      - "Please {code_task} in {language_hint}. Input shape: {input_shape}. Output shape: {output_shape}. {constraint_line}"
      - "I need help to {code_task}. Prefer {language_hint}. Inputs: {input_shape}. Outputs: {output_shape}. {constraint_line}"
      - "Help me {code_task} with {language_hint}. Assume {input_shape} and return {output_shape}. {constraint_line}"
      - "Write code to {feature_goal} using {language_hint}. Treat the input as {input_shape} and return {output_shape}. {constraint_line}"
      - |
        Refactor this snippet to {refactor_goal}:
        ```text
        {bug_snippet}
        ```
      - |
        Fix the bug and {refactor_goal} in this snippet:
        ```text
        {bug_snippet}
        ```
      - "I want to {feature_goal} in {language_hint}. Use {input_shape} and return {output_shape}. {constraint_line}"
      - |
        Please repair and improve this code (goal: {refactor_goal}):
        ```text
        {bug_snippet}
        ```

    assistant_probe:
      - "Got it. Do you want a brief explanation before the code?"
      - "Okay. Should I include a short rationale with the code?"
      - "Understood. Explanation plus code, or code only?"
      - "Thanks. Do you want me to walk through the approach first?"
      - "Got it. I can include a short explanation and the code block."

    user_followup:
      - "Include a short explanation and the code block."
      - "Explanation plus code is perfect."
      - "Give me the approach and the code."
      - "Keep the explanation short and then show the code."
      - "Yes, explain briefly and then provide the code."

    dialogue_context:
      - |
        User: {request_text}
        Assistant: {assistant_probe}
        User: {user_followup}
      - |
        User message: {request_text}
        Assistant reply: {assistant_probe}
        User follow-up: {user_followup}
      - |
        Context:
        User: {request_text}
        Assistant: {assistant_probe}
        User: {user_followup}
      - |
        Conversation:
        User: {request_text}
        Assistant: {assistant_probe}
        User: {user_followup}
      - |
        U: {request_text}
        A: {assistant_probe}
        U: {user_followup}

    assistant_response:
      - |
        Approach:
        - {bullet_line_a}
        - {bullet_line_b}
        - {bullet_line_b}
        - {bullet_line_b}
        - {bullet_line_b}

        Code:
        ```{code_language_tag}
        {code_snippet}
        ```

        Bottom line: {bottom_line}
        Next step: {next_step}
      - |
        Approach:
        - {bullet_line_a}
        - {bullet_line_b}
        - {bullet_line_b}
        - {bullet_line_b}
        - {bullet_line_b}

        Implementation:
        ```{code_language_tag}
        {code_snippet}
        ```

        Bottom line: {bottom_line}
        Next step: {next_step}

  row_template:
    language: "{language}"
    mode: "{mode}"
    tone: "{tone}"
    emote6: "{emote6}"
    representation_choice: "{representation_choice}"
    continuity_choice: "{continuity_choice}"
    intent_family: "{intent_family}"
    intent_subtype: "{intent_subtype}"
    needs_search: "{needs_search}"
    needs_history_search: "{needs_history_search}"
    history_scope: "{history_scope}"
    safety_tag: "{safety_tag}"
    user_message: "{dialogue_context}"
    assistant_response: "{assistant_response}"

notes: "Wave0 Lane15 â€” code generation (think mode, multi-turn, no teacher)"
